# Python Execution Model

## 1.1 CPython

* default Python implementation
* written in C
* compiles Python → **bytecode**
* bytecode runs in **Python Virtual Machine (PVM)**

Execution flow:

```
.py  →  compile → .pyc bytecode  → run on VM
```

### Example: compiled bytecode

```python
def add(a, b):
    return a + b
```

Python internally compiles this into bytecode instructions (you don’t usually see them).

You *can* inspect bytecode:

```python
import dis
print(dis.dis(add))
```

### 1.2 GIL — Global Interpreter Lock

* allows only **one thread** to execute Python bytecode at a time
* protects internal memory
* makes CPython simpler, safe

#### Why it matters

CPU-bound → threading is slow
IO-bound → threading is good

| Problem type             | Use             |
| ------------------------ | --------------- |
| math, ML, loops          | multiprocessing |
| API calls, DB, file wait | multithreading  |
| async processing         | asyncio         |
