# Functions

Functions in Python are reusable blocks of code designed to perform a specific task. They improve readability, modularity, and maintainability of programs.

This guide covers:

* function definition and execution model
* parameters and argument types
* return values
* scope and lifetime
* mutability impact
* default arguments
* lambda functions
* recursion
* higher-order functions
* decorators

## 1. What is a Function?

A function is:

* named block of code
* executed when called
* may receive input (parameters)
* may produce output (`return`)

### Basic structure

```python
def function_name(parameters):
    # function body
    return value
```

### Example

```python
def greet(name):
    return f"Hello, {name}"
```

Calling the function:

```python
message = greet("Alice")
print(message)
```

Output:

```
Hello, Alice
```

## 2. Function Definition vs Function Call

Definition:

```python
def add(a, b):
    return a + b
```

Call:

```python
result = add(3, 4)
print(result)
```

Output:

```
7
```

Key concept: **def does not run function**, it only defines it.

Execution happens **only when called**.

## 3. Parameters vs Arguments

* **Parameters** → variables in function definition
* **Arguments** → actual values passed during call

```python
def subtract(a, b):  # a, b = parameters
    return a - b

print(subtract(10, 3))  # 10, 3 = arguments
```

## 4. Types of Function Parameters

### 4.1 Positional parameters

Order matters.

```python
def area(length, width):
    return length * width

print(area(4, 5))
```

Output:

```
20
```

### 4.2 Keyword arguments

Order does not matter.

```python
print(area(length=4, width=5))
print(area(width=5, length=4))
```

Output:

```
20
20
```

### 4.3 Default parameters

```python
def power(base, exponent=2):
    return base ** exponent

print(power(5))      # default exponent
print(power(5, 3))   # custom exponent
```

Output:

```
25
125
```

### 4.4 Variable-length arguments

#### `*args` → positional

Collects values into a tuple.

```python
def total(*numbers):
    print(numbers)
    return sum(numbers)

print(total(1, 2, 3, 4))
```

Output:

```
(1, 2, 3, 4)
10
```

#### `**kwargs` → keyword

Collects values into a dictionary.

```python
def user_info(**details):
    print(details)

user_info(name="Alice", age=25)
```

Output:

```
{'name': 'Alice', 'age': 25}
```

## 5. Return Values

Functions may return:

* nothing (`None`)
* single value
* multiple values

### 5.1 No explicit return

```python
def hello():
    print("Hi")

print(hello())
```

Output:

```
Hi
None
```

### 5.2 Multiple return values

Python returns a **tuple** implicitly.

```python
def stats(a, b):
    return a + b, a * b

s, p = stats(3, 4)
print(s, p)
```

Output:

```
7 12
```

## 6. Pass-by-Object-Reference

Python does **not** use pass-by-value or pass-by-reference strictly.

It passes **object references**.

### 6.1 Immutable argument example

```python
def increment(x):
    x += 1

a = 10
increment(a)
print(a)
```

Output:

```
10
```

Reason: int is immutable → new object created inside function.

### 6.2 Mutable argument example

```python
def add_item(lst):
    lst.append(4)

nums = [1, 2, 3]
add_item(nums)
print(nums)
```

Output:

```
[1, 2, 3, 4]
```

Reason: list is mutable → modified in place.

## 7. Default Mutable Parameter Pitfall

❌ Dangerous example:

```python
def add_value(v, lst=[]):
    lst.append(v)
    return lst

print(add_value(1))
print(add_value(2))
```

Output:

```
[1]
[1, 2]
```

Same list reused across calls.

### Correct approach

```python
def add_value(v, lst=None):
    if lst is None:
        lst = []
    lst.append(v)
    return lst
```

## 8. Scope and Lifetime

### 8.1 Local vs Global variables

```python
x = 10  # global

def func():
    x = 5   # local
    print("Inside:", x)

func()
print("Outside:", x)
```

Output:

```
Inside: 5
Outside: 10
```

### 8.2 Modifying global variable

```python
count = 0

def increment():
    global count
    count += 1

increment()
print(count)
```

Output:

```
1
```

## 9. Lambda (Anonymous) Functions

Small inline functions.

```python
square = lambda x: x * x
print(square(6))
```

Output:

```
36
```

### Common use example: sorting

```python
data = [(1, "a"), (3, "c"), (2, "b")]
data.sort(key=lambda x: x[0])
print(data)
```

Output:

```
[(1, 'a'), (2, 'b'), (3, 'c')]
```

Avoid lambda when:

* debugging
* multiple statements
* readability matters

## 10. Recursion

Function calling itself.

```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

print(factorial(5))
```

Output:

```
120
```

## 11. Higher-Order Functions

Takes or returns a function.

```python
def apply(func, value):
    return func(value)

def double(x):
    return x * 2

print(apply(double, 5))
```

Output:

```
10
```

## 12. Decorators (intro concept)

Decorator wraps another function to extend behavior.

```python
def log(func):
    def wrapper():
        print("Function started")
        func()
        print("Function ended")
    return wrapper

@log
def hello():
    print("Hello")

hello()
```

Output:

```
Function started
Hello
Function ended
```

## 13. Best Practices

* keep functions small
* one clear responsibility
* avoid side effects when possible
* don’t use mutable objects as defaults
* document using docstrings
* write pure functions when possible
