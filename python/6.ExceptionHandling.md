# 2. Exception Handling

Used to manage runtime errors without crashing the program.

## Basic try–except

```python
try:
    x = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")
```

Output:

```
Cannot divide by zero
```

## try–except–else–finally

```python
try:
    x = int("10")
except ValueError:
    print("Conversion failed")
else:
    print("Conversion successful:", x)
finally:
    print("This always runs")
```

Output:

```
Conversion successful: 10
This always runs
```

## Custom Exceptions

Create your own class inheriting from `Exception`.

```python
class AgeTooLowError(Exception):
    pass

def register(age):
    if age < 18:
        raise AgeTooLowError("Age must be at least 18")
    return "Registered successfully"

try:
    register(16)
except AgeTooLowError as e:
    print(e)
```

Output:

```
Age must be at least 18
```

## Exception Chaining

Use `raise ... from ...`

```python
def convert_to_int(value):
    try:
        return int(value)
    except ValueError as e:
        raise TypeError("Invalid type passed") from e

convert_to_int("abc")
```

Purpose:

* retain original traceback
* debugging becomes easier
