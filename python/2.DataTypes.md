# Python Data Types and Mutability

This document explains Python’s built-in data types, their mutability characteristics, memory behavior, and practical implications. Examples demonstrate how values are stored, referenced, and modified in memory.

## 2.1 What is Mutability?

* **Mutable object**
  Can be changed **in place** after creation.
  Its `id()` (memory reference) stays the same.

* **Immutable object**
  Cannot be changed after creation.
  Any “change” creates a **new object** with a new `id()`.

### Identity vs Equality

* `is` → identity (same memory location)
* `==` → value equality (contents are same)

```python
a = [1, 2, 3]
b = a

print(a is b)   # True (same identity)
print(a == b)   # True (same value)
```

## 2.2 Core Immutable Data Types

### 2.2.1 Integers (`int`)

Integers are immutable.

```python
x = 10
print(id(x))

x += 1
print(id(x))   # new object created
```

### 2.2.2 Floating-point numbers (`float`)

```python
pi = 3.14
print(id(pi))

pi = pi + 1
print(id(pi))  # different id
```

### 2.2.3 Booleans (`bool`)

* Internally subclass of `int`
* Only two singletons exist: `True`, `False`

```python
print(True == 1)   # True
print(True is 1)   # False
```

### 2.2.4 Strings (`str`)

Strings are immutable.

```python
s = "hello"
print(id(s))

s += " world"
print(id(s))  # different object
```

### 2.2.5 Tuples (`tuple`)

Tuples are immutable, but **may contain mutable elements**.

```python
t = (1, 2, 3)
# t[0] = 10   # TypeError

# tuple with mutable item
t2 = ([1, 2], 3)
t2[0].append(3)     # allowed
print(t2)           # ([1, 2, 3], 3)
```

### 2.2.6 Frozenset (`frozenset`)

Immutable version of `set`.

```python
s = frozenset({1, 2, 3})
# s.add(4)  # AttributeError
```

### 2.2.7 `NoneType`

Represents absence of value.

```python
x = None
print(type(x))
```

### 2.2.8 `bytes`

Immutable sequence of bytes.

```python
b = bytes([65, 66, 67])
print(b)
# b[0] = 90  # TypeError
```

## 2.3 Core Mutable Data Types

### 2.3.1 Lists (`list`)

Ordered, mutable sequence.

```python
nums = [1, 2, 3]
print(id(nums))

nums.append(4)
print(nums)
print(id(nums))   # same id, mutated in place
```

### 2.3.2 Dictionaries (`dict`)

Key–value mapping, mutable.

```python
person = {"name": "Alice", "age": 25}
print(id(person))

person["age"] = 26
print(person)
print(id(person))  # same id
```

### 2.3.3 Sets (`set`)

Unordered, unique items, mutable.

```python
s = {1, 2, 3}
print(id(s))

s.add(4)
print(s)
print(id(s))  # same id
```

### 2.3.4 `bytearray`

Mutable byte sequence.

```python
ba = bytearray(b"ABC")
ba[0] = 90
print(ba)  # b'ZBC'
```

## 2.4 Special Iterables

### 2.4.1 `range`

Immutable arithmetic progression

```python
r = range(1, 5)
print(list(r))
```

### 2.4.2 `memoryview`

Efficient view over binary data

```python
data = bytearray(b"ABCD")
mv = memoryview(data)
mv[0] = 90
print(data)  # b'ZBCD'
```

## 2.5 Copying Mutable and Immutable Objects

### 2.5.1 Assignment = same object

```python
a = [1, 2]
b = a

b.append(3)
print(a)  # [1, 2, 3]
```

### 2.5.2 Shallow copy

```python
import copy

a = [[1], [2]]
b = copy.copy(a)

b[0].append(99)
print(a)  # [[1, 99], [2]]
```

### 2.5.3 Deep copy

```python
import copy

a = [[1], [2]]
b = copy.deepcopy(a)

b[0].append(99)
print(a)  # [[1], [2]]
```

## 2.6 Mutability and Function Arguments

### Immutable example

```python
def increment(x):
    x += 1

a = 10
increment(a)
print(a)  # 10
```

### Mutable example

```python
def add_item(lst):
    lst.append(4)

nums = [1, 2, 3]
add_item(nums)
print(nums)  # [1, 2, 3, 4]
```

## 2.7 Mutability Pitfall: Default Mutable Arguments

```python
def add_value(v, lst=[]):
    lst.append(v)
    return lst

print(add_value(1))  # [1]
print(add_value(2))  # [1, 2]  <-- same list reused
```

### Correct pattern

```python
def add_value(v, lst=None):
    if lst is None:
        lst = []
    lst.append(v)
    return lst
```

## 2.8 Conditions and Loops Examples

### Using mutable and immutable objects in loops

```python
nums = [1, 2, 3]
total = 0

for n in nums:
    total += n

print(total)
```

### Condition with dict lookup

```python
user = {"role": "admin"}

if user["role"] == "admin":
    print("Access granted")
```

## 2.9 Practical Guidelines

* Prefer tuples for **read-only** ordered data
* Prefer lists for frequently updated sequences
* Do not use mutable defaults in functions
* Use `frozenset` as dictionary keys when you need immutability
* Understand that **immutability improves safety and hashability**

## 2.10 Summary Table

| Type      | Mutable | Ordered | Example             |
| --------- | ------- | ------- | ------------------- |
| int       | No      | N/A     | `10`                |
| float     | No      | N/A     | `3.14`              |
| bool      | No      | N/A     | `True`              |
| str       | No      | Yes     | `"hello"`           |
| tuple     | No      | Yes     | `(1, 2)`            |
| frozenset | No      | No      | `frozenset({1, 2})` |
| bytes     | No      | Yes     | `b"ABC"`            |
| list      | Yes     | Yes     | `[1, 2, 3]`         |
| dict      | Yes     | No      | `{"a": 1}`          |
| set       | Yes     | No      | `{1, 2, 3}`         |
| bytearray | Yes     | Yes     | `bytearray(b"ABC")` |

