# Python Advanced

## 1. Modules & Packages

### What is a Module?

A **module** is a single Python file `.py` that contains:

* functions
* classes
* variables

Python loads modules **once** and caches them in `sys.modules`.

### Why modules exist internally

When you `import math`:

1. Python searches in this order:

   * built-ins
   * `sys.path`
   * current directory
2. Compiles to bytecode (`.pyc`)
3. Stores in `__pycache__`
4. Registers in `sys.modules`

This prevents **re-import cost**.

### Code Example — Creating a Module

**math_utils.py**

```python
def add(a, b):
    return a + b

PI = 3.14
```

**main.py**

```python
import math_utils

print(math_utils.add(2, 3))
print(math_utils.PI)
```

**Output**

```
5
3.14
```

### What is a Package?

A package is:

* a **directory** containing modules
* plus an `__init__.py` file

```
mypackage/
    __init__.py
    math_utils.py
    string_utils.py
```

### Why `__init__.py` matters

It:

* marks directory as a package
* controls exports
* runs initialization code

**`__init__.py` example**

```python
from .math_utils import add
```

Now you can:

```python
from mypackage import add
```

## 2. Object-Oriented Python (OOP)

### What is a Class?

A **class** defines behavior & data.

An **object** is an instance of a class stored in heap memory.

### Under the hood

* every class is of type `type`
* every instance stores attributes in `__dict__`
* methods are descriptors bound to instance

### 2.1 Classes, objects, constructors

```python
class Person:
    def __init__(self, name, age):  # constructor
        self.name = name
        self.age = age

    def speak(self):
        print(f"My name is {self.name}")
```

**Usage**

```python
p = Person("John", 25)
p.speak()
```

**Output**

```
My name is John
```

### 2.2 Inheritance vs Composition

#### Inheritance — “is a”

```python
class Animal:
    def eat(self):
        print("Eating")

class Dog(Animal):
    def bark(self):
        print("Barking")
```

Usage

```python
d = Dog()
d.eat()
d.bark()
```

Output

```
Eating
Barking
```

#### Composition — “has a”

```python
class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self):
        self.engine = Engine()  # has a

    def drive(self):
        self.engine.start()
        print("Car moving")
```

Composition is preferred for **loose coupling**.

### 2.3 Magic / Dunder Methods

These customize Python behavior.

| Method     | Meaning         |
| - |  |
| `__str__`  | user readable   |
| `__repr__` | developer debug |
| `__eq__`   | equality        |
| `__len__`  | length          |
| `__add__`  | + operator      |
| `__iter__` | iteration       |

Example:

```python
class Book:
    def __init__(self, title, pages):
        self.title = title
        self.pages = pages

    def __str__(self):
        return self.title

    def __len__(self):
        return self.pages
```

Usage:

```python
b = Book("Python", 500)
print(str(b))
print(len(b))
```

Output:

```
Python
500
```

### 2.4 Dataclasses

They **auto-generate**:

* constructor
* repr
* eq

```python
from dataclasses import dataclass

@dataclass
class User:
    name: str
    age: int
```

Usage:

```python
u = User("Alice", 22)
print(u)
```

Output:

```
User(name='Alice', age=22)
```

### 2.5 Abstract Base Classes (abc)

Force subclasses to implement methods.

```python
from abc import ABC, abstractmethod

class Shape(ABC):

    @abstractmethod
    def area(self):
        pass
```

Child must implement:

```python
class Circle(Shape):
    def __init__(self, r):
        self.r = r

    def area(self):
        return 3.14 * self.r * self.r
```

## 3. Iterators & Generators

### Iterator protocol

Object must implement:

* `__iter__`
* `__next__`

Example:

```python
class Count:
    def __init__(self, limit):
        self.limit = limit
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.limit:
            raise StopIteration
        self.current += 1
        return self.current
```

Usage:

```python
for i in Count(3):
    print(i)
```

Output:

```
1
2
3
```

### Generators

Use `yield` to produce values lazily.

```python
def generate_numbers():
    yield 1
    yield 2
    yield 3
```

or with loop

```python
def count(n):
    for i in range(n):
        yield i
```

This saves **memory**.

## 4. Context Managers

Used with `with`.

Guarantees cleanup.

```python
class FileManager:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, "r")
        return self.file

    def __exit__(self, exc_type, exc, tb):
        self.file.close()
```

Usage:

```python
with FileManager("test.txt") as f:
    print(f.read())
```

`__exit__` runs even on exception.

## 5. Decorators

A decorator wraps a function.

```python
def log(func):
    def wrapper(*args, **kwargs):
        print("Calling", func.__name__)
        return func(*args, **kwargs)
    return wrapper
```

Usage:

```python
@log
def add(a, b):
    return a + b
```

Output:

```
Calling add
```

Use cases:

* authentication
* logging
* retries
* timing

## 6. Type Hints

Examples:

```python
from typing import List, Dict, Optional, Union

def greet(name: str) -> str:
    return "Hello " + name
```

Union:

```python
def to_int(x: Union[int, str]) -> int:
    return int(x)
```

Optional:

```python
def find(name: Optional[str]):
    if name:
        print(name)
```

Protocols define behavior contracts.

## 7. Async Programming

### async / await

Runs concurrently, not parallel.

```python
import asyncio

async def task():
    print("Task running")
    await asyncio.sleep(1)
    print("Task finished")

asyncio.run(task())
```

### Event loop basics

* schedules coroutines
* cooperatively multitasks
* switches on `await`

### Blocking vs Non-blocking

Blocking:

```python
import time

def work():
    time.sleep(5)
```

Non-blocking:

```python
async def async_work():
    await asyncio.sleep(5)
```
